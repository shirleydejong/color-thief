{"version":3,"file":"color-thief.modern.js","sources":["../node_modules/quantize/dist/index.mjs","../src/color-thief.js","../src/core.js"],"sourcesContent":["/*\n * quantize.js Copyright 2008 Nick Rabinowitz\n * Ported to node.js by Olivier Lesnicki\n * Licensed under the MIT license: http://www.opensource.org/licenses/mit-license.php\n */\n// fill out a couple protovis dependencies\n\n/*\n * Block below copied from Protovis: http://mbostock.github.com/protovis/\n * Copyright 2010 Stanford Visualization Group\n * Licensed under the BSD License: http://www.opensource.org/licenses/bsd-license.php\n */\nif (!pv) {\n  var pv = {\n    map: function (array, f) {\n      var o = {};\n      return f ? array.map(function (d, i) {\n        o.index = i;\n        return f.call(o, d);\n      }) : array.slice();\n    },\n    naturalOrder: function (a, b) {\n      return a < b ? -1 : a > b ? 1 : 0;\n    },\n    sum: function (array, f) {\n      var o = {};\n      return array.reduce(f ? function (p, d, i) {\n        o.index = i;\n        return p + f.call(o, d);\n      } : function (p, d) {\n        return p + d;\n      }, 0);\n    },\n    max: function (array, f) {\n      return Math.max.apply(null, f ? pv.map(array, f) : array);\n    }\n  };\n}\n/**\n * Basic Javascript port of the MMCQ (modified median cut quantization)\n * algorithm from the Leptonica library (http://www.leptonica.com/).\n * Returns a color map you can use to map original pixels to the reduced\n * palette. Still a work in progress.\n * \n * @author Nick Rabinowitz\n * @example\n \n// array of pixels as [R,G,B] arrays\nvar myPixels = [[190,197,190], [202,204,200], [207,214,210], [211,214,211], [205,207,207]\n                // etc\n                ];\nvar maxColors = 4;\n \nvar cmap = MMCQ.quantize(myPixels, maxColors);\nvar newPalette = cmap.palette();\nvar newPixels = myPixels.map(function(p) { \n    return cmap.map(p); \n});\n \n */\n\n\nvar MMCQ = function () {\n  // private constants\n  var sigbits = 5,\n      rshift = 8 - sigbits,\n      maxIterations = 1000,\n      fractByPopulations = 0.75; // get reduced-space color index for a pixel\n\n  function getColorIndex(r, g, b) {\n    return (r << 2 * sigbits) + (g << sigbits) + b;\n  } // Simple priority queue\n\n\n  function PQueue(comparator) {\n    var contents = [],\n        sorted = false;\n\n    function sort() {\n      contents.sort(comparator);\n      sorted = true;\n    }\n\n    return {\n      push: function (o) {\n        contents.push(o);\n        sorted = false;\n      },\n      peek: function (index) {\n        if (!sorted) { sort(); }\n        if (index === undefined) { index = contents.length - 1; }\n        return contents[index];\n      },\n      pop: function () {\n        if (!sorted) { sort(); }\n        return contents.pop();\n      },\n      size: function () {\n        return contents.length;\n      },\n      map: function (f) {\n        return contents.map(f);\n      },\n      debug: function () {\n        if (!sorted) { sort(); }\n        return contents;\n      }\n    };\n  } // 3d color space box\n\n\n  function VBox(r1, r2, g1, g2, b1, b2, histo) {\n    var vbox = this;\n    vbox.r1 = r1;\n    vbox.r2 = r2;\n    vbox.g1 = g1;\n    vbox.g2 = g2;\n    vbox.b1 = b1;\n    vbox.b2 = b2;\n    vbox.histo = histo;\n  }\n\n  VBox.prototype = {\n    volume: function (force) {\n      var vbox = this;\n\n      if (!vbox._volume || force) {\n        vbox._volume = (vbox.r2 - vbox.r1 + 1) * (vbox.g2 - vbox.g1 + 1) * (vbox.b2 - vbox.b1 + 1);\n      }\n\n      return vbox._volume;\n    },\n    count: function (force) {\n      var vbox = this,\n          histo = vbox.histo;\n\n      if (!vbox._count_set || force) {\n        var npix = 0,\n            i,\n            j,\n            k,\n            index;\n\n        for (i = vbox.r1; i <= vbox.r2; i++) {\n          for (j = vbox.g1; j <= vbox.g2; j++) {\n            for (k = vbox.b1; k <= vbox.b2; k++) {\n              index = getColorIndex(i, j, k);\n              npix += histo[index] || 0;\n            }\n          }\n        }\n\n        vbox._count = npix;\n        vbox._count_set = true;\n      }\n\n      return vbox._count;\n    },\n    copy: function () {\n      var vbox = this;\n      return new VBox(vbox.r1, vbox.r2, vbox.g1, vbox.g2, vbox.b1, vbox.b2, vbox.histo);\n    },\n    avg: function (force) {\n      var vbox = this,\n          histo = vbox.histo;\n\n      if (!vbox._avg || force) {\n        var ntot = 0,\n            mult = 1 << 8 - sigbits,\n            rsum = 0,\n            gsum = 0,\n            bsum = 0,\n            hval,\n            i,\n            j,\n            k,\n            histoindex;\n\n        for (i = vbox.r1; i <= vbox.r2; i++) {\n          for (j = vbox.g1; j <= vbox.g2; j++) {\n            for (k = vbox.b1; k <= vbox.b2; k++) {\n              histoindex = getColorIndex(i, j, k);\n              hval = histo[histoindex] || 0;\n              ntot += hval;\n              rsum += hval * (i + 0.5) * mult;\n              gsum += hval * (j + 0.5) * mult;\n              bsum += hval * (k + 0.5) * mult;\n            }\n          }\n        }\n\n        if (ntot) {\n          vbox._avg = [~~(rsum / ntot), ~~(gsum / ntot), ~~(bsum / ntot)];\n        } else {\n          //console.log('empty box');\n          vbox._avg = [~~(mult * (vbox.r1 + vbox.r2 + 1) / 2), ~~(mult * (vbox.g1 + vbox.g2 + 1) / 2), ~~(mult * (vbox.b1 + vbox.b2 + 1) / 2)];\n        }\n      }\n\n      return vbox._avg;\n    },\n    contains: function (pixel) {\n      var vbox = this,\n          rval = pixel[0] >> rshift;\n      gval = pixel[1] >> rshift;\n      bval = pixel[2] >> rshift;\n      return rval >= vbox.r1 && rval <= vbox.r2 && gval >= vbox.g1 && gval <= vbox.g2 && bval >= vbox.b1 && bval <= vbox.b2;\n    }\n  }; // Color map\n\n  function CMap() {\n    this.vboxes = new PQueue(function (a, b) {\n      return pv.naturalOrder(a.vbox.count() * a.vbox.volume(), b.vbox.count() * b.vbox.volume());\n    });\n  }\n\n  CMap.prototype = {\n    push: function (vbox) {\n      this.vboxes.push({\n        vbox: vbox,\n        color: vbox.avg()\n      });\n    },\n    palette: function () {\n      return this.vboxes.map(function (vb) {\n        return vb.color;\n      });\n    },\n    size: function () {\n      return this.vboxes.size();\n    },\n    map: function (color) {\n      var vboxes = this.vboxes;\n\n      for (var i = 0; i < vboxes.size(); i++) {\n        if (vboxes.peek(i).vbox.contains(color)) {\n          return vboxes.peek(i).color;\n        }\n      }\n\n      return this.nearest(color);\n    },\n    nearest: function (color) {\n      var vboxes = this.vboxes,\n          d1,\n          d2,\n          pColor;\n\n      for (var i = 0; i < vboxes.size(); i++) {\n        d2 = Math.sqrt(Math.pow(color[0] - vboxes.peek(i).color[0], 2) + Math.pow(color[1] - vboxes.peek(i).color[1], 2) + Math.pow(color[2] - vboxes.peek(i).color[2], 2));\n\n        if (d2 < d1 || d1 === undefined) {\n          d1 = d2;\n          pColor = vboxes.peek(i).color;\n        }\n      }\n\n      return pColor;\n    },\n    forcebw: function () {\n      // XXX: won't  work yet\n      var vboxes = this.vboxes;\n      vboxes.sort(function (a, b) {\n        return pv.naturalOrder(pv.sum(a.color), pv.sum(b.color));\n      }); // force darkest color to black if everything < 5\n\n      var lowest = vboxes[0].color;\n      if (lowest[0] < 5 && lowest[1] < 5 && lowest[2] < 5) { vboxes[0].color = [0, 0, 0]; } // force lightest color to white if everything > 251\n\n      var idx = vboxes.length - 1,\n          highest = vboxes[idx].color;\n      if (highest[0] > 251 && highest[1] > 251 && highest[2] > 251) { vboxes[idx].color = [255, 255, 255]; }\n    }\n  }; // histo (1-d array, giving the number of pixels in\n  // each quantized region of color space), or null on error\n\n  function getHisto(pixels) {\n    var histosize = 1 << 3 * sigbits,\n        histo = new Array(histosize),\n        index,\n        rval,\n        gval,\n        bval;\n    pixels.forEach(function (pixel) {\n      rval = pixel[0] >> rshift;\n      gval = pixel[1] >> rshift;\n      bval = pixel[2] >> rshift;\n      index = getColorIndex(rval, gval, bval);\n      histo[index] = (histo[index] || 0) + 1;\n    });\n    return histo;\n  }\n\n  function vboxFromPixels(pixels, histo) {\n    var rmin = 1000000,\n        rmax = 0,\n        gmin = 1000000,\n        gmax = 0,\n        bmin = 1000000,\n        bmax = 0,\n        rval,\n        gval,\n        bval; // find min/max\n\n    pixels.forEach(function (pixel) {\n      rval = pixel[0] >> rshift;\n      gval = pixel[1] >> rshift;\n      bval = pixel[2] >> rshift;\n      if (rval < rmin) { rmin = rval; }else if (rval > rmax) { rmax = rval; }\n      if (gval < gmin) { gmin = gval; }else if (gval > gmax) { gmax = gval; }\n      if (bval < bmin) { bmin = bval; }else if (bval > bmax) { bmax = bval; }\n    });\n    return new VBox(rmin, rmax, gmin, gmax, bmin, bmax, histo);\n  }\n\n  function medianCutApply(histo, vbox) {\n    if (!vbox.count()) { return; }\n    var rw = vbox.r2 - vbox.r1 + 1,\n        gw = vbox.g2 - vbox.g1 + 1,\n        bw = vbox.b2 - vbox.b1 + 1,\n        maxw = pv.max([rw, gw, bw]); // only one pixel, no split\n\n    if (vbox.count() == 1) {\n      return [vbox.copy()];\n    }\n    /* Find the partial sum arrays along the selected axis. */\n\n\n    var total = 0,\n        partialsum = [],\n        lookaheadsum = [],\n        i,\n        j,\n        k,\n        sum,\n        index;\n\n    if (maxw == rw) {\n      for (i = vbox.r1; i <= vbox.r2; i++) {\n        sum = 0;\n\n        for (j = vbox.g1; j <= vbox.g2; j++) {\n          for (k = vbox.b1; k <= vbox.b2; k++) {\n            index = getColorIndex(i, j, k);\n            sum += histo[index] || 0;\n          }\n        }\n\n        total += sum;\n        partialsum[i] = total;\n      }\n    } else if (maxw == gw) {\n      for (i = vbox.g1; i <= vbox.g2; i++) {\n        sum = 0;\n\n        for (j = vbox.r1; j <= vbox.r2; j++) {\n          for (k = vbox.b1; k <= vbox.b2; k++) {\n            index = getColorIndex(j, i, k);\n            sum += histo[index] || 0;\n          }\n        }\n\n        total += sum;\n        partialsum[i] = total;\n      }\n    } else {\n      /* maxw == bw */\n      for (i = vbox.b1; i <= vbox.b2; i++) {\n        sum = 0;\n\n        for (j = vbox.r1; j <= vbox.r2; j++) {\n          for (k = vbox.g1; k <= vbox.g2; k++) {\n            index = getColorIndex(j, k, i);\n            sum += histo[index] || 0;\n          }\n        }\n\n        total += sum;\n        partialsum[i] = total;\n      }\n    }\n\n    partialsum.forEach(function (d, i) {\n      lookaheadsum[i] = total - d;\n    });\n\n    function doCut(color) {\n      var dim1 = color + '1',\n          dim2 = color + '2',\n          left,\n          right,\n          vbox1,\n          vbox2,\n          d2,\n          count2 = 0;\n\n      for (i = vbox[dim1]; i <= vbox[dim2]; i++) {\n        if (partialsum[i] > total / 2) {\n          vbox1 = vbox.copy();\n          vbox2 = vbox.copy();\n          left = i - vbox[dim1];\n          right = vbox[dim2] - i;\n          if (left <= right) { d2 = Math.min(vbox[dim2] - 1, ~~(i + right / 2)); }else { d2 = Math.max(vbox[dim1], ~~(i - 1 - left / 2)); } // avoid 0-count boxes\n\n          while (!partialsum[d2]) { d2++; }\n\n          count2 = lookaheadsum[d2];\n\n          while (!count2 && partialsum[d2 - 1]) { count2 = lookaheadsum[--d2]; } // set dimensions\n\n\n          vbox1[dim2] = d2;\n          vbox2[dim1] = vbox1[dim2] + 1; // console.log('vbox counts:', vbox.count(), vbox1.count(), vbox2.count());\n\n          return [vbox1, vbox2];\n        }\n      }\n    } // determine the cut planes\n\n\n    return maxw == rw ? doCut('r') : maxw == gw ? doCut('g') : doCut('b');\n  }\n\n  function quantize(pixels, maxcolors) {\n    // short-circuit\n    if (!pixels.length || maxcolors < 2 || maxcolors > 256) {\n      // console.log('wrong number of maxcolors');\n      return false;\n    } // XXX: check color content and convert to grayscale if insufficient\n\n\n    var histo = getHisto(pixels);\n // check that we aren't below maxcolors already\n    histo.forEach(function () {\n    });\n    // get the beginning vbox from the colors\n\n\n    var vbox = vboxFromPixels(pixels, histo),\n        pq = new PQueue(function (a, b) {\n      return pv.naturalOrder(a.count(), b.count());\n    });\n    pq.push(vbox); // inner function to do the iteration\n\n    function iter(lh, target) {\n      var ncolors = lh.size(),\n          niters = 0,\n          vbox;\n\n      while (niters < maxIterations) {\n        if (ncolors >= target) { return; }\n\n        if (niters++ > maxIterations) {\n          // console.log(\"infinite loop; perhaps too few pixels!\");\n          return;\n        }\n\n        vbox = lh.pop();\n\n        if (!vbox.count()) {\n          /* just put it back */\n          lh.push(vbox);\n          niters++;\n          continue;\n        } // do the cut\n\n\n        var vboxes = medianCutApply(histo, vbox),\n            vbox1 = vboxes[0],\n            vbox2 = vboxes[1];\n\n        if (!vbox1) {\n          // console.log(\"vbox1 not defined; shouldn't happen!\");\n          return;\n        }\n\n        lh.push(vbox1);\n\n        if (vbox2) {\n          /* vbox2 can be null */\n          lh.push(vbox2);\n          ncolors++;\n        }\n      }\n    } // first set of colors, sorted by population\n\n\n    iter(pq, fractByPopulations * maxcolors); // console.log(pq.size(), pq.debug().length, pq.debug().slice());\n    // Re-sort by the product of pixel occupancy times the size in color space.\n\n    var pq2 = new PQueue(function (a, b) {\n      return pv.naturalOrder(a.count() * a.volume(), b.count() * b.volume());\n    });\n\n    while (pq.size()) {\n      pq2.push(pq.pop());\n    } // next set - generate the median cuts using the (npix * vol) sorting.\n\n\n    iter(pq2, maxcolors); // calculate the actual colors\n\n    var cmap = new CMap();\n\n    while (pq2.size()) {\n      cmap.push(pq2.pop());\n    }\n\n    return cmap;\n  }\n\n  return {\n    quantize: quantize\n  };\n}();\n\nvar quantize = MMCQ.quantize;\n\nexport default quantize;\n","import quantize from '../node_modules/quantize/dist/index.mjs';\r\nimport core from './core.js';\r\n\r\n/*\r\n * Color Thief v2.3.2\r\n * by Lokesh Dhakar - http://www.lokeshdhakar.com\r\n *\r\n * Thanks\r\n * ------\r\n * Nick Rabinowitz - For creating quantize.js.\r\n * John Schulz - For clean up and optimization. @JFSIII\r\n * Nathan Spady - For adding drag and drop support to the demo page.\r\n *\r\n * License\r\n * -------\r\n * Copyright Lokesh Dhakar\r\n * Released under the MIT license\r\n * https://raw.githubusercontent.com/lokesh/color-thief/master/LICENSE\r\n *\r\n * @license\r\n */\r\n\r\n\r\n/*\r\n  CanvasImage Class\r\n  Class that wraps the html image element and canvas.\r\n  It also simplifies some of the canvas context manipulation\r\n  with a set of helper functions.\r\n*/\r\n\r\nconst CanvasImage = function (image) {\r\n    this.canvas  = document.createElement('canvas');\r\n    this.context = this.canvas.getContext('2d');\r\n    this.width  = this.canvas.width  = image.naturalWidth;\r\n    this.height = this.canvas.height = image.naturalHeight;\r\n    this.context.drawImage(image, 0, 0, this.width, this.height);\r\n};\r\n\r\nCanvasImage.prototype.getImageData = function () {\r\n    return this.context.getImageData(0, 0, this.width, this.height);\r\n};\r\n\r\nvar ColorThief = function () {};\r\n\r\n/*\r\n * getColor(sourceImage[, quality])\r\n * returns {r: num, g: num, b: num}\r\n *\r\n * Use the median cut algorithm provided by quantize.js to cluster similar\r\n * colors and return the base color from the largest cluster.\r\n *\r\n * Quality is an optional argument. It needs to be an integer. 1 is the highest quality settings.\r\n * 10 is the default. There is a trade-off between quality and speed. The bigger the number, the\r\n * faster a color will be returned but the greater the likelihood that it will not be the visually\r\n * most dominant color.\r\n *\r\n * */\r\nColorThief.prototype.getColor = function(sourceImage, quality = 10) {\r\n    const palette       = this.getPalette(sourceImage, 5, quality);\r\n    const dominantColor = palette[0];\r\n    return dominantColor;\r\n};\r\n\r\n\r\n/*\r\n * getPalette(sourceImage[, colorCount, quality])\r\n * returns array[ {r: num, g: num, b: num}, {r: num, g: num, b: num}, ...]\r\n *\r\n * Use the median cut algorithm provided by quantize.js to cluster similar colors.\r\n *\r\n * colorCount determines the size of the palette; the number of colors returned. If not set, it\r\n * defaults to 10.\r\n *\r\n * quality is an optional argument. It needs to be an integer. 1 is the highest quality settings.\r\n * 10 is the default. There is a trade-off between quality and speed. The bigger the number, the\r\n * faster the palette generation but the greater the likelihood that colors will be missed.\r\n *\r\n *\r\n */\r\nColorThief.prototype.getPalette = function(sourceImage, colorCount, quality) {\r\n    const options = core.validateOptions({\r\n        colorCount,\r\n        quality\r\n    });\r\n\r\n    // Create custom CanvasImage object\r\n    const image      = new CanvasImage(sourceImage);\r\n    const imageData  = image.getImageData();\r\n    const pixelCount = image.width * image.height;\r\n\r\n    const pixelArray = core.createPixelArray(imageData.data, pixelCount, options.quality);\r\n\r\n    // Send array to quantize function which clusters values\r\n    // using median cut algorithm\r\n    const cmap    = quantize(pixelArray, options.colorCount);\r\n    const palette = cmap? cmap.palette() : null;\r\n\r\n    return palette;\r\n};\r\n\r\nColorThief.prototype.getColorFromUrl = function(imageUrl, callback, quality) {\r\n    const sourceImage = document.createElement(\"img\");\r\n\r\n    sourceImage.addEventListener('load' , () => {\r\n        const palette = this.getPalette(sourceImage, 5, quality);\r\n        const dominantColor = palette[0];\r\n        callback(dominantColor, imageUrl);\r\n    });\r\n    sourceImage.src = imageUrl\r\n};\r\n\r\n\r\nColorThief.prototype.getImageData = function(imageUrl, callback) {\r\n    let xhr = new XMLHttpRequest();\r\n    xhr.open('GET', imageUrl, true);\r\n    xhr.responseType = 'arraybuffer';\r\n    xhr.onload = function() {\r\n        if (this.status == 200) {\r\n            let uInt8Array = new Uint8Array(this.response);\r\n            i = uInt8Array.length;\r\n            let binaryString = new Array(i);\r\n            for (let i = 0; i < uInt8Array.length; i++){\r\n                binaryString[i] = String.fromCharCode(uInt8Array[i]);\r\n            }\r\n            let data = binaryString.join('');\r\n            let base64 = window.btoa(data);\r\n            callback ('data:image/png;base64,' + base64);\r\n        }\r\n    }\r\n    xhr.send();\r\n};\r\n\r\nColorThief.prototype.getColorAsync = function(imageUrl, callback, quality) {\r\n    const thief = this;\r\n    this.getImageData(imageUrl, function(imageData){\r\n        const sourceImage = document.createElement(\"img\");\r\n        sourceImage.addEventListener('load' , function(){\r\n            const palette = thief.getPalette(sourceImage, 5, quality);\r\n            const dominantColor = palette[0];\r\n            callback(dominantColor, this);\r\n        });\r\n        sourceImage.src = imageData;\r\n    });\r\n};\r\n\r\n\r\nexport default ColorThief;\r\n","function createPixelArray(imgData, pixelCount, quality) {\n\tconst pixels = imgData;\n\tconst pixelArray = [];\n\n\tfor (let i = 0, offset, r, g, b, a; i < pixelCount; i = i + quality) {\n\t\toffset = i * 4;\n\t\tr = pixels[offset + 0];\n\t\tg = pixels[offset + 1];\n\t\tb = pixels[offset + 2];\n\t\ta = pixels[offset + 3];\n\n\t\t// If pixel is mostly opaque and not white\n\t\tif (typeof a === 'undefined' || a >= 125) {\n\t\t\tif (!(r > 250 && g > 250 && b > 250)) {\n\t\t\t\tpixelArray.push([r, g, b]);\n\t\t\t}\n\t\t}\n\t}\n\treturn pixelArray;\n}\n\nfunction validateOptions(options) {\n\tlet { colorCount, quality } = options;\n\n\tif (typeof colorCount === 'undefined' || !Number.isInteger(colorCount)) {\n\t\tcolorCount = 10;\n\t} else if (colorCount === 1 ) {\n\t\tthrow new Error('colorCount should be between 2 and 20. To get one color, call getColor() instead of getPalette()');\n\t} else {\n\t\tcolorCount = Math.max(colorCount, 2);\n\t\tcolorCount = Math.min(colorCount, 20);\n\t}\n\n\tif (typeof quality === 'undefined' || !Number.isInteger(quality) || quality < 1) {\n\t\tquality = 10;\n\t}\n\n\treturn {\n\t\tcolorCount,\n\t\tquality\n\t}\n}\n\nexport default {\n\tcreatePixelArray,\n\tvalidateOptions\n};\n"],"names":["pv","map","array","f","o","d","i","index","call","slice","naturalOrder","a","b","sum","reduce","p","max","Math","apply","quantize","sigbits","rshift","maxIterations","getColorIndex","r","g","PQueue","comparator","contents","sorted","sort","push","peek","undefined","length","pop","size","debug","VBox","r1","r2","g1","g2","b1","b2","histo","vbox","this","CMap","vboxes","count","volume","medianCutApply","rw","gw","maxw","copy","j","k","total","partialsum","lookaheadsum","forEach","color","left","right","vbox1","vbox2","d2","dim1","dim2","count2","min","doCut","prototype","force","_volume","_count_set","npix","_count","avg","_avg","hval","ntot","mult","rsum","gsum","bsum","contains","pixel","rval","gval","bval","palette","vb","nearest","d1","pColor","sqrt","pow","forcebw","lowest","idx","highest","pixels","maxcolors","Array","getHisto","rmin","rmax","gmin","gmax","bmin","bmax","vboxFromPixels","pq","iter","lh","target","ncolors","niters","pq2","cmap","CanvasImage","image","canvas","document","createElement","context","getContext","width","naturalWidth","height","naturalHeight","drawImage","getImageData","ColorThief","getColor","sourceImage","quality","getPalette","colorCount","options","Number","isInteger","Error","core","pixelArray","imgData","pixelCount","offset","data","getColorFromUrl","imageUrl","callback","addEventListener","src","xhr","XMLHttpRequest","open","responseType","onload","status","uInt8Array","Uint8Array","response","binaryString","String","fromCharCode","join","base64","window","btoa","send","getColorAsync","imageData","thief"],"mappings":"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"}