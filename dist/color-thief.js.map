{"version":3,"file":"color-thief.modern.js","sources":["../node_modules/quantize/dist/index.mjs","../src/color-thief.js","../src/core.js"],"sourcesContent":["/*\n * quantize.js Copyright 2008 Nick Rabinowitz\n * Ported to node.js by Olivier Lesnicki\n * Licensed under the MIT license: http://www.opensource.org/licenses/mit-license.php\n */\n\n// fill out a couple protovis dependencies\n/*\n * Block below copied from Protovis: http://mbostock.github.com/protovis/\n * Copyright 2010 Stanford Visualization Group\n * Licensed under the BSD License: http://www.opensource.org/licenses/bsd-license.php\n */\nif (!pv) {\n  var pv = {\n    map: function map(array, f) {\n      var o = {};\n      return f ? array.map(function (d, i) {\n        o.index = i;\n        return f.call(o, d);\n      }) : array.slice();\n    },\n    naturalOrder: function naturalOrder(a, b) {\n      return a < b ? -1 : a > b ? 1 : 0;\n    },\n    sum: function sum(array, f) {\n      var o = {};\n      return array.reduce(f ? function (p, d, i) {\n        o.index = i;\n        return p + f.call(o, d);\n      } : function (p, d) {\n        return p + d;\n      }, 0);\n    },\n    max: function max(array, f) {\n      return Math.max.apply(null, f ? pv.map(array, f) : array);\n    }\n  };\n}\n\n/**\n * Basic Javascript port of the MMCQ (modified median cut quantization)\n * algorithm from the Leptonica library (http://www.leptonica.com/).\n * Returns a color map you can use to map original pixels to the reduced\n * palette. Still a work in progress.\n * \n * @author Nick Rabinowitz\n * @example\n \n// array of pixels as [R,G,B] arrays\nvar myPixels = [[190,197,190], [202,204,200], [207,214,210], [211,214,211], [205,207,207]\n                // etc\n                ];\nvar maxColors = 4;\n \nvar cmap = MMCQ.quantize(myPixels, maxColors);\nvar newPalette = cmap.palette();\nvar newPixels = myPixels.map(function(p) { \n    return cmap.map(p); \n});\n \n */\nvar MMCQ = function () {\n  // private constants\n  var sigbits = 5,\n    rshift = 8 - sigbits,\n    maxIterations = 1000,\n    fractByPopulations = 0.75;\n\n  // get reduced-space color index for a pixel\n\n  function getColorIndex(r, g, b) {\n    return (r << 2 * sigbits) + (g << sigbits) + b;\n  }\n\n  // Simple priority queue\n\n  function PQueue(comparator) {\n    var contents = [],\n      sorted = false;\n    function sort() {\n      contents.sort(comparator);\n      sorted = true;\n    }\n    return {\n      push: function push(o) {\n        contents.push(o);\n        sorted = false;\n      },\n      peek: function peek(index) {\n        if (!sorted) sort();\n        if (index === undefined) index = contents.length - 1;\n        return contents[index];\n      },\n      pop: function pop() {\n        if (!sorted) sort();\n        return contents.pop();\n      },\n      size: function size() {\n        return contents.length;\n      },\n      map: function map(f) {\n        return contents.map(f);\n      },\n      debug: function debug() {\n        if (!sorted) sort();\n        return contents;\n      }\n    };\n  }\n\n  // 3d color space box\n\n  function VBox(r1, r2, g1, g2, b1, b2, histo) {\n    var vbox = this;\n    vbox.r1 = r1;\n    vbox.r2 = r2;\n    vbox.g1 = g1;\n    vbox.g2 = g2;\n    vbox.b1 = b1;\n    vbox.b2 = b2;\n    vbox.histo = histo;\n  }\n  VBox.prototype = {\n    volume: function volume(force) {\n      var vbox = this;\n      if (!vbox._volume || force) {\n        vbox._volume = (vbox.r2 - vbox.r1 + 1) * (vbox.g2 - vbox.g1 + 1) * (vbox.b2 - vbox.b1 + 1);\n      }\n      return vbox._volume;\n    },\n    count: function count(force) {\n      var vbox = this,\n        histo = vbox.histo;\n      if (!vbox._count_set || force) {\n        var npix = 0,\n          i,\n          j,\n          k,\n          index;\n        for (i = vbox.r1; i <= vbox.r2; i++) {\n          for (j = vbox.g1; j <= vbox.g2; j++) {\n            for (k = vbox.b1; k <= vbox.b2; k++) {\n              index = getColorIndex(i, j, k);\n              npix += histo[index] || 0;\n            }\n          }\n        }\n        vbox._count = npix;\n        vbox._count_set = true;\n      }\n      return vbox._count;\n    },\n    copy: function copy() {\n      var vbox = this;\n      return new VBox(vbox.r1, vbox.r2, vbox.g1, vbox.g2, vbox.b1, vbox.b2, vbox.histo);\n    },\n    avg: function avg(force) {\n      var vbox = this,\n        histo = vbox.histo;\n      if (!vbox._avg || force) {\n        var ntot = 0,\n          mult = 1 << 8 - sigbits,\n          rsum = 0,\n          gsum = 0,\n          bsum = 0,\n          hval,\n          i,\n          j,\n          k,\n          histoindex;\n        for (i = vbox.r1; i <= vbox.r2; i++) {\n          for (j = vbox.g1; j <= vbox.g2; j++) {\n            for (k = vbox.b1; k <= vbox.b2; k++) {\n              histoindex = getColorIndex(i, j, k);\n              hval = histo[histoindex] || 0;\n              ntot += hval;\n              rsum += hval * (i + 0.5) * mult;\n              gsum += hval * (j + 0.5) * mult;\n              bsum += hval * (k + 0.5) * mult;\n            }\n          }\n        }\n        if (ntot) {\n          vbox._avg = [~~(rsum / ntot), ~~(gsum / ntot), ~~(bsum / ntot)];\n        } else {\n          //console.log('empty box');\n          vbox._avg = [~~(mult * (vbox.r1 + vbox.r2 + 1) / 2), ~~(mult * (vbox.g1 + vbox.g2 + 1) / 2), ~~(mult * (vbox.b1 + vbox.b2 + 1) / 2)];\n        }\n      }\n      return vbox._avg;\n    },\n    contains: function contains(pixel) {\n      var vbox = this,\n        rval = pixel[0] >> rshift;\n      gval = pixel[1] >> rshift;\n      bval = pixel[2] >> rshift;\n      return rval >= vbox.r1 && rval <= vbox.r2 && gval >= vbox.g1 && gval <= vbox.g2 && bval >= vbox.b1 && bval <= vbox.b2;\n    }\n  };\n\n  // Color map\n\n  function CMap() {\n    this.vboxes = new PQueue(function (a, b) {\n      return pv.naturalOrder(a.vbox.count() * a.vbox.volume(), b.vbox.count() * b.vbox.volume());\n    });\n  }\n  CMap.prototype = {\n    push: function push(vbox) {\n      this.vboxes.push({\n        vbox: vbox,\n        color: vbox.avg()\n      });\n    },\n    palette: function palette() {\n      return this.vboxes.map(function (vb) {\n        return vb.color;\n      });\n    },\n    size: function size() {\n      return this.vboxes.size();\n    },\n    map: function map(color) {\n      var vboxes = this.vboxes;\n      for (var i = 0; i < vboxes.size(); i++) {\n        if (vboxes.peek(i).vbox.contains(color)) {\n          return vboxes.peek(i).color;\n        }\n      }\n      return this.nearest(color);\n    },\n    nearest: function nearest(color) {\n      var vboxes = this.vboxes,\n        d1,\n        d2,\n        pColor;\n      for (var i = 0; i < vboxes.size(); i++) {\n        d2 = Math.sqrt(Math.pow(color[0] - vboxes.peek(i).color[0], 2) + Math.pow(color[1] - vboxes.peek(i).color[1], 2) + Math.pow(color[2] - vboxes.peek(i).color[2], 2));\n        if (d2 < d1 || d1 === undefined) {\n          d1 = d2;\n          pColor = vboxes.peek(i).color;\n        }\n      }\n      return pColor;\n    },\n    forcebw: function forcebw() {\n      // XXX: won't  work yet\n      var vboxes = this.vboxes;\n      vboxes.sort(function (a, b) {\n        return pv.naturalOrder(pv.sum(a.color), pv.sum(b.color));\n      });\n\n      // force darkest color to black if everything < 5\n      var lowest = vboxes[0].color;\n      if (lowest[0] < 5 && lowest[1] < 5 && lowest[2] < 5) vboxes[0].color = [0, 0, 0];\n\n      // force lightest color to white if everything > 251\n      var idx = vboxes.length - 1,\n        highest = vboxes[idx].color;\n      if (highest[0] > 251 && highest[1] > 251 && highest[2] > 251) vboxes[idx].color = [255, 255, 255];\n    }\n  };\n\n  // histo (1-d array, giving the number of pixels in\n  // each quantized region of color space), or null on error\n\n  function getHisto(pixels) {\n    var histosize = 1 << 3 * sigbits,\n      histo = new Array(histosize),\n      index,\n      rval,\n      gval,\n      bval;\n    pixels.forEach(function (pixel) {\n      rval = pixel[0] >> rshift;\n      gval = pixel[1] >> rshift;\n      bval = pixel[2] >> rshift;\n      index = getColorIndex(rval, gval, bval);\n      histo[index] = (histo[index] || 0) + 1;\n    });\n    return histo;\n  }\n  function vboxFromPixels(pixels, histo) {\n    var rmin = 1000000,\n      rmax = 0,\n      gmin = 1000000,\n      gmax = 0,\n      bmin = 1000000,\n      bmax = 0,\n      rval,\n      gval,\n      bval;\n    // find min/max\n    pixels.forEach(function (pixel) {\n      rval = pixel[0] >> rshift;\n      gval = pixel[1] >> rshift;\n      bval = pixel[2] >> rshift;\n      if (rval < rmin) rmin = rval;else if (rval > rmax) rmax = rval;\n      if (gval < gmin) gmin = gval;else if (gval > gmax) gmax = gval;\n      if (bval < bmin) bmin = bval;else if (bval > bmax) bmax = bval;\n    });\n    return new VBox(rmin, rmax, gmin, gmax, bmin, bmax, histo);\n  }\n  function medianCutApply(histo, vbox) {\n    if (!vbox.count()) return;\n    var rw = vbox.r2 - vbox.r1 + 1,\n      gw = vbox.g2 - vbox.g1 + 1,\n      bw = vbox.b2 - vbox.b1 + 1,\n      maxw = pv.max([rw, gw, bw]);\n    // only one pixel, no split\n    if (vbox.count() == 1) {\n      return [vbox.copy()];\n    }\n    /* Find the partial sum arrays along the selected axis. */\n    var total = 0,\n      partialsum = [],\n      lookaheadsum = [],\n      i,\n      j,\n      k,\n      sum,\n      index;\n    if (maxw == rw) {\n      for (i = vbox.r1; i <= vbox.r2; i++) {\n        sum = 0;\n        for (j = vbox.g1; j <= vbox.g2; j++) {\n          for (k = vbox.b1; k <= vbox.b2; k++) {\n            index = getColorIndex(i, j, k);\n            sum += histo[index] || 0;\n          }\n        }\n        total += sum;\n        partialsum[i] = total;\n      }\n    } else if (maxw == gw) {\n      for (i = vbox.g1; i <= vbox.g2; i++) {\n        sum = 0;\n        for (j = vbox.r1; j <= vbox.r2; j++) {\n          for (k = vbox.b1; k <= vbox.b2; k++) {\n            index = getColorIndex(j, i, k);\n            sum += histo[index] || 0;\n          }\n        }\n        total += sum;\n        partialsum[i] = total;\n      }\n    } else {\n      /* maxw == bw */\n      for (i = vbox.b1; i <= vbox.b2; i++) {\n        sum = 0;\n        for (j = vbox.r1; j <= vbox.r2; j++) {\n          for (k = vbox.g1; k <= vbox.g2; k++) {\n            index = getColorIndex(j, k, i);\n            sum += histo[index] || 0;\n          }\n        }\n        total += sum;\n        partialsum[i] = total;\n      }\n    }\n    partialsum.forEach(function (d, i) {\n      lookaheadsum[i] = total - d;\n    });\n    function doCut(color) {\n      var dim1 = color + '1',\n        dim2 = color + '2',\n        left,\n        right,\n        vbox1,\n        vbox2,\n        d2,\n        count2 = 0;\n      for (i = vbox[dim1]; i <= vbox[dim2]; i++) {\n        if (partialsum[i] > total / 2) {\n          vbox1 = vbox.copy();\n          vbox2 = vbox.copy();\n          left = i - vbox[dim1];\n          right = vbox[dim2] - i;\n          if (left <= right) d2 = Math.min(vbox[dim2] - 1, ~~(i + right / 2));else d2 = Math.max(vbox[dim1], ~~(i - 1 - left / 2));\n          // avoid 0-count boxes\n          while (!partialsum[d2]) d2++;\n          count2 = lookaheadsum[d2];\n          while (!count2 && partialsum[d2 - 1]) count2 = lookaheadsum[--d2];\n          // set dimensions\n          vbox1[dim2] = d2;\n          vbox2[dim1] = vbox1[dim2] + 1;\n          // console.log('vbox counts:', vbox.count(), vbox1.count(), vbox2.count());\n          return [vbox1, vbox2];\n        }\n      }\n    }\n    // determine the cut planes\n    return maxw == rw ? doCut('r') : maxw == gw ? doCut('g') : doCut('b');\n  }\n  function quantize(pixels, maxcolors) {\n    // short-circuit\n    if (!pixels.length || maxcolors < 2 || maxcolors > 256) {\n      // console.log('wrong number of maxcolors');\n      return false;\n    }\n\n    // XXX: check color content and convert to grayscale if insufficient\n\n    var histo = getHisto(pixels);\n    histo.forEach(function () {\n    });\n\n    // get the beginning vbox from the colors\n    var vbox = vboxFromPixels(pixels, histo),\n      pq = new PQueue(function (a, b) {\n        return pv.naturalOrder(a.count(), b.count());\n      });\n    pq.push(vbox);\n\n    // inner function to do the iteration\n\n    function iter(lh, target) {\n      var ncolors = lh.size(),\n        niters = 0,\n        vbox;\n      while (niters < maxIterations) {\n        if (ncolors >= target) return;\n        if (niters++ > maxIterations) {\n          // console.log(\"infinite loop; perhaps too few pixels!\");\n          return;\n        }\n        vbox = lh.pop();\n        if (!vbox.count()) {\n          /* just put it back */\n          lh.push(vbox);\n          niters++;\n          continue;\n        }\n        // do the cut\n        var vboxes = medianCutApply(histo, vbox),\n          vbox1 = vboxes[0],\n          vbox2 = vboxes[1];\n        if (!vbox1) {\n          // console.log(\"vbox1 not defined; shouldn't happen!\");\n          return;\n        }\n        lh.push(vbox1);\n        if (vbox2) {\n          /* vbox2 can be null */\n          lh.push(vbox2);\n          ncolors++;\n        }\n      }\n    }\n\n    // first set of colors, sorted by population\n    iter(pq, fractByPopulations * maxcolors);\n    // console.log(pq.size(), pq.debug().length, pq.debug().slice());\n\n    // Re-sort by the product of pixel occupancy times the size in color space.\n    var pq2 = new PQueue(function (a, b) {\n      return pv.naturalOrder(a.count() * a.volume(), b.count() * b.volume());\n    });\n    while (pq.size()) {\n      pq2.push(pq.pop());\n    }\n\n    // next set - generate the median cuts using the (npix * vol) sorting.\n    iter(pq2, maxcolors);\n\n    // calculate the actual colors\n    var cmap = new CMap();\n    while (pq2.size()) {\n      cmap.push(pq2.pop());\n    }\n    return cmap;\n  }\n  return {\n    quantize: quantize\n  };\n}();\nvar quantize = MMCQ.quantize;\n\nexport { quantize as default };\n","import quantize from '../node_modules/quantize/dist/index.mjs';\nimport core from './core.js';\n\n/*\n * Color Thief v2.3.2\n * by Lokesh Dhakar - http://www.lokeshdhakar.com\n *\n * Thanks\n * ------\n * Nick Rabinowitz - For creating quantize.js.\n * John Schulz - For clean up and optimization. @JFSIII\n * Nathan Spady - For adding drag and drop support to the demo page.\n *\n * License\n * -------\n * Copyright Lokesh Dhakar\n * Released under the MIT license\n * https://raw.githubusercontent.com/lokesh/color-thief/master/LICENSE\n *\n * @license\n */\n\n\n/*\n  CanvasImage Class\n  Class that wraps the html image element and canvas.\n  It also simplifies some of the canvas context manipulation\n  with a set of helper functions.\n*/\n\nconst CanvasImage = function (image) {\n    this.canvas  = document.createElement('canvas');\n    this.context = this.canvas.getContext('2d');\n    this.width  = this.canvas.width  = image.naturalWidth;\n    this.height = this.canvas.height = image.naturalHeight;\n    this.context.drawImage(image, 0, 0, this.width, this.height);\n};\n\nCanvasImage.prototype.getImageData = function () {\n    return this.context.getImageData(0, 0, this.width, this.height);\n};\n\nvar ColorThief = function () {};\n\n/*\n * getColor(sourceImage[, quality])\n * returns {r: num, g: num, b: num}\n *\n * Use the median cut algorithm provided by quantize.js to cluster similar\n * colors and return the base color from the largest cluster.\n *\n * Quality is an optional argument. It needs to be an integer. 1 is the highest quality settings.\n * 10 is the default. There is a trade-off between quality and speed. The bigger the number, the\n * faster a color will be returned but the greater the likelihood that it will not be the visually\n * most dominant color.\n *\n * */\nColorThief.prototype.getColor = function(sourceImage, quality = 10) {\n    const palette       = this.getPalette(sourceImage, 5, quality);\n    const dominantColor = palette[0];\n    return dominantColor;\n};\n\n\n/*\n * getPalette(sourceImage[, colorCount, quality])\n * returns array[ {r: num, g: num, b: num}, {r: num, g: num, b: num}, ...]\n *\n * Use the median cut algorithm provided by quantize.js to cluster similar colors.\n *\n * colorCount determines the size of the palette; the number of colors returned. If not set, it\n * defaults to 10.\n *\n * quality is an optional argument. It needs to be an integer. 1 is the highest quality settings.\n * 10 is the default. There is a trade-off between quality and speed. The bigger the number, the\n * faster the palette generation but the greater the likelihood that colors will be missed.\n *\n *\n */\nColorThief.prototype.getPalette = function(sourceImage, colorCount, quality) {\n    const options = core.validateOptions({\n        colorCount,\n        quality\n    });\n\n    // Create custom CanvasImage object\n    const image      = new CanvasImage(sourceImage);\n    const imageData  = image.getImageData();\n    const pixelCount = image.width * image.height;\n\n    const pixelArray = core.createPixelArray(imageData.data, pixelCount, options.quality);\n\n    // Send array to quantize function which clusters values\n    // using median cut algorithm\n    const cmap    = quantize(pixelArray, options.colorCount);\n    const palette = cmap? cmap.palette() : null;\n\n    return palette;\n};\n\nColorThief.prototype.getColorFromUrl = function(imageUrl, callback, quality) {\n    const sourceImage = document.createElement(\"img\");\n\n    sourceImage.addEventListener('load' , () => {\n        const palette = this.getPalette(sourceImage, 5, quality);\n        const dominantColor = palette[0];\n        callback(dominantColor, imageUrl);\n    });\n    sourceImage.src = imageUrl\n};\n\n\nColorThief.prototype.getImageData = function(imageUrl, callback) {\n    let xhr = new XMLHttpRequest();\n    xhr.open('GET', imageUrl, true);\n    xhr.responseType = 'arraybuffer';\n    xhr.onload = function() {\n        if (this.status == 200) {\n            let uInt8Array = new Uint8Array(this.response);\n            i = uInt8Array.length;\n            let binaryString = new Array(i);\n            for (let i = 0; i < uInt8Array.length; i++){\n                binaryString[i] = String.fromCharCode(uInt8Array[i]);\n            }\n            let data = binaryString.join('');\n            let base64 = window.btoa(data);\n            callback ('data:image/png;base64,' + base64);\n        }\n    }\n    xhr.send();\n};\n\nColorThief.prototype.getColorAsync = function(imageUrl, callback, quality) {\n    const thief = this;\n    this.getImageData(imageUrl, function(imageData){\n        const sourceImage = document.createElement(\"img\");\n        sourceImage.addEventListener('load' , function(){\n            const palette = thief.getPalette(sourceImage, 5, quality);\n            const dominantColor = palette[0];\n            callback(dominantColor, this);\n        });\n        sourceImage.src = imageData;\n    });\n};\n\n\nexport default ColorThief;\n","function createPixelArray(imgData, pixelCount, quality) {\n\tconst pixels = imgData;\n\tconst pixelArray = [];\n\n\tfor (let i = 0, offset, r, g, b, a; i < pixelCount; i = i + quality) {\n\t\toffset = i * 4;\n\t\tr = pixels[offset + 0];\n\t\tg = pixels[offset + 1];\n\t\tb = pixels[offset + 2];\n\t\ta = pixels[offset + 3];\n\n\t\t// If pixel is mostly opaque and not white\n\t\tif (typeof a === 'undefined' || a >= 125) {\n\t\t\tif (!(r > 250 && g > 250 && b > 250)) {\n\t\t\t\tpixelArray.push([r, g, b]);\n\t\t\t}\n\t\t}\n\t}\n\treturn pixelArray;\n}\n\nfunction validateOptions(options) {\n\tlet { colorCount, quality } = options;\n\n\tif (typeof colorCount === 'undefined' || !Number.isInteger(colorCount)) {\n\t\tcolorCount = 10;\n\t} else if (colorCount === 1 ) {\n\t\tthrow new Error('colorCount should be between 2 and 20. To get one color, call getColor() instead of getPalette()');\n\t} else {\n\t\tcolorCount = Math.max(colorCount, 2);\n\t\tcolorCount = Math.min(colorCount, 20);\n\t}\n\n\tif (typeof quality === 'undefined' || !Number.isInteger(quality) || quality < 1) {\n\t\tquality = 10;\n\t}\n\n\treturn {\n\t\tcolorCount,\n\t\tquality\n\t}\n}\n\nexport default {\n\tcreatePixelArray,\n\tvalidateOptions\n};\n"],"names":["pv","map","array","f","o","d","i","index","call","slice","naturalOrder","a","b","sum","reduce","p","max","Math","apply","quantize","sigbits","rshift","maxIterations","getColorIndex","r","g","PQueue","comparator","contents","sorted","sort","push","peek","undefined","length","pop","size","debug","VBox","r1","r2","g1","g2","b1","b2","histo","vbox","this","CMap","vboxes","count","volume","medianCutApply","rw","gw","maxw","copy","j","k","total","partialsum","lookaheadsum","forEach","color","left","right","vbox1","vbox2","d2","dim1","dim2","count2","min","doCut","prototype","force","_volume","_count_set","npix","_count","avg","_avg","hval","ntot","mult","rsum","gsum","bsum","contains","pixel","rval","gval","bval","palette","vb","nearest","d1","pColor","sqrt","pow","forcebw","lowest","idx","highest","pixels","maxcolors","Array","getHisto","rmin","rmax","gmin","gmax","bmin","bmax","vboxFromPixels","pq","iter","lh","target","ncolors","niters","pq2","cmap","CanvasImage","image","canvas","document","createElement","context","getContext","width","naturalWidth","height","naturalHeight","drawImage","getImageData","ColorThief","getColor","sourceImage","quality","getPalette","colorCount","options","Number","isInteger","Error","core","pixelArray","imgData","pixelCount","offset","data","getColorFromUrl","imageUrl","callback","addEventListener","src","xhr","XMLHttpRequest","open","responseType","onload","status","uInt8Array","Uint8Array","response","binaryString","String","fromCharCode","join","base64","window","btoa","send","getColorAsync","imageData","thief"],"mappings":"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"}